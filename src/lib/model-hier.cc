#include "pialign/model-hier.h"

using namespace pialign;
using namespace std;

Prob HierModel::addSentence(const WordString & e, const WordString & f, SpanNode* node, StringWordSet & ePhrases, StringWordSet & fPhrases, PairWordSet & pairs, std::vector<Prob>& baseProbs) {
    if(!node || !node->add) return 0;
    // get the phrase IDs
    Prob totProb = 0;
    const Span & mySpan = node->span;
    int s=mySpan.es,t=mySpan.ee,u=mySpan.fs,v=mySpan.fe;
    WordId eId = ePhrases.getId(e.substr(s,t-s),true),
        fId = fPhrases.getId(f.substr(u,v-u),true);
    node->phraseid = pairs.getId(std::pair<WordId,WordId>(eId,fId),true);
    int toAdd = node->type;
    // handle either non-terminals or terminals
    if(toAdd == TYPE_REG || toAdd == TYPE_INV) {
        totProb += addSentence(e,f,node->right,ePhrases,fPhrases,pairs,baseProbs);
        totProb += addSentence(e,f,node->left,ePhrases,fPhrases,pairs,baseProbs);
    } else if(toAdd != TYPE_GEN) {
        if((int)baseProbs.size() <= node->phraseid) 
            baseProbs.resize(node->phraseid+1, NEG_INFINITY);
        baseProbs[node->phraseid] = node->baseProb;
        totProb += node->baseProb;
        toAdd = TYPE_TERM;
    }
    // find the left and right nodes
    WordId lId = (node->left?node->left->phraseid:-1),
            rId = (node->right?node->right->phraseid:-1);
    // add the appropriate values for the derivation
    if(node->type == TYPE_GEN) {
        totProb = log(phrases_.getProb(node->phraseid,0));
        phrases_.addExisting(node->phraseid);
    } else {
        totProb += log(phrases_.getFallbackProb());
        totProb += addType(toAdd);
        phrases_.addNew(node->phraseid,lId,rId,toAdd);
    }
    addAverageDerivation(node->phraseid,phrases_.getTotal(node->phraseid),node->prob);
    return totProb;
}

SpanNode* HierModel::removePhrasePair(WordId jId, std::vector<Prob>& baseProbs) {
    if(jId < 0) return 0;
    SpanNode* ret = new SpanNode(Span(0,0,0,0));
    ret->phraseid = jId;
    ret->prob = phrases_.remove(jId);
    // this was generated from the fallback
    if(phrases_.isRemovedTable()) {
        PyTable<WordId> table = phrases_.getLastTable();
        ret->prob += removeType(table.type);
        ret->type = table.type;
        // generated by breaking down
        if(table.right >= 0) {
            ret->right = removePhrasePair(table.right,baseProbs);
            ret->prob += ret->right->prob;
            ret->left = removePhrasePair(table.left,baseProbs);
            ret->prob += ret->left->prob;
        }
        // generated directly from the base measure
        else {
            ret->prob += baseProbs[jId];
            ret->baseProb = baseProbs[jId];
            ret->type = TYPE_BASE;
        }
    }
    // this was generated from the cache
    else 
        ret->type = TYPE_GEN;
    return ret;
}
